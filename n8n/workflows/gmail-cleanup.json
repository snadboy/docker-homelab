{
  "name": "Gmail Cleanup",
  "description": "Ports gmail-trim cleanup logic. Discovers KEEP/KEEP_nnn labels, loads keeper contacts, scans threads. Default: dry-run. Live: ?mode=live. Webhook: /webhook/gmail-cleanup",
  "nodes": [
    {
      "parameters": {
        "path": "gmail-cleanup",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        192,
        144
      ],
      "webhookId": "gmail-cleanup"
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "Gmail Cleanup started",
        "options": {}
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        384,
        144
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "mode",
              "name": "mode",
              "value": "={{ $json.query.mode || 'dry-run' }}",
              "type": "string"
            },
            {
              "id": "days",
              "name": "days",
              "value": "={{ $json.query.days || '30' }}",
              "type": "string"
            },
            {
              "id": "max",
              "name": "max",
              "value": "={{ $json.query.max || '500' }}",
              "type": "string"
            },
            {
              "id": "keepLabel",
              "name": "keepLabel",
              "value": "={{ $json.query.keep_label || 'KEEP' }}",
              "type": "string"
            },
            {
              "id": "gci",
              "name": "googleClientId",
              "value": "={{ $env.GOOGLE_CLIENT_ID }}",
              "type": "string"
            },
            {
              "id": "gcs",
              "name": "googleClientSecret",
              "value": "={{ $env.GOOGLE_CLIENT_SECRET }}",
              "type": "string"
            },
            {
              "id": "grt",
              "name": "googleRefreshToken",
              "value": "={{ $env.GOOGLE_REFRESH_TOKEN }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "set-webhook-config",
      "name": "Set Webhook Config",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        384,
        288
      ]
    },
    {
      "parameters": {
        "path": "gmail-cleanup-dry",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "dry-run-trigger",
      "name": "Dry Run",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        176,
        480
      ],
      "webhookId": "gmail-cleanup-dry"
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "Gmail Cleanup dry-run started",
        "options": {}
      },
      "id": "respond-dry-run",
      "name": "Respond Dry Run",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        384,
        480
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "mode",
              "name": "mode",
              "value": "dry-run",
              "type": "string"
            },
            {
              "id": "days",
              "name": "days",
              "value": "30",
              "type": "string"
            },
            {
              "id": "max",
              "name": "max",
              "value": "500",
              "type": "string"
            },
            {
              "id": "keepLabel",
              "name": "keepLabel",
              "value": "KEEP",
              "type": "string"
            },
            {
              "id": "gci",
              "name": "googleClientId",
              "value": "={{ $env.GOOGLE_CLIENT_ID }}",
              "type": "string"
            },
            {
              "id": "gcs",
              "name": "googleClientSecret",
              "value": "={{ $env.GOOGLE_CLIENT_SECRET }}",
              "type": "string"
            },
            {
              "id": "grt",
              "name": "googleRefreshToken",
              "value": "={{ $env.GOOGLE_REFRESH_TOKEN }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "set-dry-config",
      "name": "Set Dry Run Config",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        384,
        640
      ]
    },
    {
      "parameters": {
        "path": "gmail-cleanup-live",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "live-run-trigger",
      "name": "Live Run",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        176,
        832
      ],
      "webhookId": "gmail-cleanup-live"
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "Gmail Cleanup LIVE started - threads will be trashed",
        "options": {}
      },
      "id": "respond-live-run",
      "name": "Respond Live Run",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        384,
        832
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "mode",
              "name": "mode",
              "value": "live",
              "type": "string"
            },
            {
              "id": "days",
              "name": "days",
              "value": "30",
              "type": "string"
            },
            {
              "id": "max",
              "name": "max",
              "value": "500",
              "type": "string"
            },
            {
              "id": "keepLabel",
              "name": "keepLabel",
              "value": "KEEP",
              "type": "string"
            },
            {
              "id": "gci",
              "name": "googleClientId",
              "value": "={{ $env.GOOGLE_CLIENT_ID }}",
              "type": "string"
            },
            {
              "id": "gcs",
              "name": "googleClientSecret",
              "value": "={{ $env.GOOGLE_CLIENT_SECRET }}",
              "type": "string"
            },
            {
              "id": "grt",
              "name": "googleRefreshToken",
              "value": "={{ $env.GOOGLE_REFRESH_TOKEN }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "set-live-config",
      "name": "Set Live Config",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        384,
        1008
      ]
    },
    {
      "parameters": {
        "jsCode": "// Gmail Cleanup - Full cleanup logic ported from gmail-trim\n// Triggers: /gmail-cleanup (query params), /gmail-cleanup-dry, /gmail-cleanup-live\n\nconst items = $input.all();\nconst { googleClientId, googleClientSecret, googleRefreshToken } = items[0].json;\n\n// Read mode/config from upstream Set node\nconst mode = (items[0].json.mode || 'dry-run').toLowerCase();\nconst daysThreshold = parseInt(items[0].json.days || '30', 10);\nconst keepLabel = items[0].json.keepLabel || 'KEEP';\nconst maxThreads = parseInt(items[0].json.max || '500', 10);\n\n// Validate\nif (mode !== 'dry-run' && mode !== 'live') {\n  return [{ json: { report: `ERROR: Invalid mode \"${mode}\". Use \"dry-run\" or \"live\".`, mode } }];\n}\nif (daysThreshold < 1 || daysThreshold > 365) {\n  return [{ json: { report: `ERROR: days must be 1-365, got ${daysThreshold}`, mode } }];\n}\n\n// Get OAuth2 access token\nconst tokenBody = `client_id=${encodeURIComponent(googleClientId)}&client_secret=${encodeURIComponent(googleClientSecret)}&refresh_token=${encodeURIComponent(googleRefreshToken)}&grant_type=refresh_token`;\nconst tokenResp = await this.helpers.httpRequest({\n  method: 'POST',\n  url: 'https://oauth2.googleapis.com/token',\n  body: tokenBody,\n  headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n});\nconst accessToken = tokenResp.access_token;\n\n// Helper: authenticated API requests\nasync function apiRequest(url, method = 'GET') {\n  return await this.helpers.httpRequest({\n    method,\n    url,\n    headers: { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' }\n  });\n}\n\n// Helper: parse KEEP_nD/W/M labels to days\nfunction parseKeepDaysLabel(labelName) {\n  const match = labelName.match(/^KEEP_(\\d{1,3})(D|W|M)$/i);\n  if (!match) return null;\n  const value = parseInt(match[1], 10);\n  const unit = match[2].toLowerCase();\n  const multipliers = { d: 1, w: 7, m: 30 };\n  const days = value * (multipliers[unit] || 1);\n  return (days >= 1 && days <= 3650) ? days : null;\n}\n\n// Helper: extract email addresses from header value\nfunction extractEmails(headerValue) {\n  if (!headerValue) return [];\n  const emailRegex = /[\\w.+-]+@[\\w.-]+\\.\\w+/gi;\n  return (headerValue.match(emailRegex) || []).map(e => e.toLowerCase());\n}\n\nconst errors = [];\nconst stats = {\n  threadsScanned: 0,\n  threadsDeleted: 0,\n  preservedByKeepLabel: 0,\n  preservedByContact: 0,\n  preservedByRetention: 0,\n  preservedByKeepDaysActive: 0,\n  errors: 0\n};\n\n// ============================================================\n// PHASE 1: Discover labels\n// ============================================================\nconst labelsResp = await apiRequest.call(this, 'https://gmail.googleapis.com/gmail/v1/users/me/labels');\nconst allLabels = labelsResp.labels || [];\n\n// Build label maps\nconst labelIdToName = {};\nconst labelNameToId = {};\nfor (const l of allLabels) {\n  labelIdToName[l.id] = l.name;\n  labelNameToId[l.name.toUpperCase()] = l.id;\n}\n\n// Find KEEP label ID\nconst keepLabelId = labelNameToId[keepLabel.toUpperCase()] || null;\n\n// Find all KEEP_nnn labels with retention days\nconst keepDaysLabels = {};\nfor (const l of allLabels) {\n  const days = parseKeepDaysLabel(l.name);\n  if (days !== null) {\n    keepDaysLabels[l.name] = days;\n  }\n}\n\n// ============================================================\n// PHASE 2: Load keeper contacts (People API)\n// ============================================================\nconst keeperEmails = new Set();\n\ntry {\n  const groupsResp = await apiRequest.call(this, 'https://people.googleapis.com/v1/contactGroups?pageSize=1000');\n  const contactGroups = (groupsResp.contactGroups || []).filter(g => g.groupType === 'USER_CONTACT_GROUP');\n  const keeperGroup = contactGroups.find(g => g.name.toLowerCase() === 'keeper');\n\n  if (keeperGroup) {\n    const groupDetail = await apiRequest.call(this, `https://people.googleapis.com/v1/${keeperGroup.resourceName}?maxMembers=1000`);\n    const memberResourceNames = groupDetail.memberResourceNames || [];\n\n    for (let i = 0; i < memberResourceNames.length; i += 50) {\n      const batch = memberResourceNames.slice(i, i + 50);\n      const params = batch.map(r => `resourceNames=${encodeURIComponent(r)}`).join('&');\n      const peopleResp = await apiRequest.call(this, `https://people.googleapis.com/v1/people:batchGet?${params}&personFields=emailAddresses`);\n\n      for (const resp of (peopleResp.responses || [])) {\n        const emails = ((resp.person || {}).emailAddresses || []).map(e => e.value).filter(Boolean);\n        for (const email of emails) {\n          keeperEmails.add(email.toLowerCase());\n        }\n      }\n    }\n  }\n} catch (e) {\n  errors.push(`Contacts API: ${e.message}`);\n}\n\n// ============================================================\n// PHASE 3: Build search query\n// ============================================================\n// Replicate gmail_client.py:build_search_query() logic\nfunction buildSearchQuery() {\n  const commonExclusions = ['-in:trash', '-in:spam'];\n  const commonStr = commonExclusions.join(' ');\n\n  if (Object.keys(keepDaysLabels).length === 0) {\n    // Simple query - no KEEP_nnn labels\n    const parts = [`older_than:${daysThreshold}d`, `-label:${keepLabel}`];\n    parts.push(...commonExclusions);\n    return parts.join(' ');\n  }\n\n  // Compound OR query for KEEP_nnn retention\n  // Part 1: Base query - old emails without any KEEP labels\n  const baseParts = [`older_than:${daysThreshold}d`, `-label:${keepLabel}`];\n  for (const labelName of Object.keys(keepDaysLabels)) {\n    baseParts.push(`-label:${labelName}`);\n  }\n  baseParts.push(commonStr);\n  const baseQuery = `(${baseParts.join(' ')})`;\n\n  // Part 2: Individual KEEP_nnn queries (expired retention)\n  const labelQueries = [];\n  for (const [labelName, retDays] of Object.entries(keepDaysLabels)) {\n    const lqParts = [`older_than:${retDays}d`, `label:${labelName}`, commonStr];\n    labelQueries.push(`(${lqParts.join(' ')})`);\n  }\n\n  return [baseQuery, ...labelQueries].join(' OR ');\n}\n\nconst searchQuery = buildSearchQuery();\n\n// ============================================================\n// PHASE 4: Fetch matching threads with pagination\n// ============================================================\nlet allThreadIds = [];\nlet pageToken = null;\n\ndo {\n  let url = `https://gmail.googleapis.com/gmail/v1/users/me/threads?q=${encodeURIComponent(searchQuery)}&maxResults=100`;\n  if (pageToken) url += `&pageToken=${pageToken}`;\n\n  const threadsResp = await apiRequest.call(this, url);\n  const threads = threadsResp.threads || [];\n  allThreadIds.push(...threads.map(t => t.id));\n  pageToken = threadsResp.nextPageToken || null;\n\n  // Safety limit\n  if (allThreadIds.length >= maxThreads) {\n    allThreadIds = allThreadIds.slice(0, maxThreads);\n    break;\n  }\n} while (pageToken);\n\n// ============================================================\n// PHASE 5: Process each thread - determine preservation\n// ============================================================\nconst toDelete = [];\nconst preserved = [];\n\nfor (const threadId of allThreadIds) {\n  stats.threadsScanned++;\n\n  try {\n    // Get thread metadata\n    const thread = await apiRequest.call(this, `https://gmail.googleapis.com/gmail/v1/users/me/threads/${threadId}?format=metadata&metadataHeaders=From&metadataHeaders=To&metadataHeaders=Cc&metadataHeaders=Subject&metadataHeaders=Date`);\n\n    const messages = thread.messages || [];\n    if (messages.length === 0) continue;\n\n    // Get thread labels (union of all message labels)\n    const threadLabelIds = new Set();\n    for (const msg of messages) {\n      for (const lid of (msg.labelIds || [])) {\n        threadLabelIds.add(lid);\n      }\n    }\n\n    // Get thread label names\n    const threadLabelNames = [...threadLabelIds].map(id => labelIdToName[id] || id);\n\n    // Extract all email addresses from thread\n    const threadAddresses = new Set();\n    let threadSubject = '';\n    let threadDate = null;\n\n    for (const msg of messages) {\n      const headers = msg.payload?.headers || [];\n      for (const h of headers) {\n        const name = h.name.toLowerCase();\n        if (name === 'from' || name === 'to' || name === 'cc') {\n          for (const email of extractEmails(h.value)) {\n            threadAddresses.add(email);\n          }\n        }\n        if (name === 'subject' && !threadSubject) {\n          threadSubject = h.value || '';\n        }\n        if (name === 'date' && !threadDate) {\n          threadDate = new Date(h.value);\n        }\n      }\n    }\n\n    // Determine thread status (preservation check)\n    // Priority: 1. KEEP label  2. Keeper contact  3. KEEP_nnn retention\n\n    // 1. Check KEEP label\n    if (keepLabelId && threadLabelIds.has(keepLabelId)) {\n      stats.preservedByKeepLabel++;\n      preserved.push({ subject: threadSubject.substring(0, 60), reason: 'KEEP label' });\n      continue;\n    }\n\n    // 2. Check keeper contacts\n    let isKeeperContact = false;\n    for (const addr of threadAddresses) {\n      if (keeperEmails.has(addr)) {\n        isKeeperContact = true;\n        stats.preservedByContact++;\n        preserved.push({ subject: threadSubject.substring(0, 60), reason: `keeper: ${addr}` });\n        break;\n      }\n    }\n    if (isKeeperContact) continue;\n\n    // 3. Check KEEP_nnn labels (within retention)\n    let maxRetention = 0;\n    let retentionLabel = null;\n    for (const lName of threadLabelNames) {\n      const retDays = parseKeepDaysLabel(lName);\n      if (retDays !== null && retDays > maxRetention) {\n        maxRetention = retDays;\n        retentionLabel = lName;\n      }\n    }\n\n    if (retentionLabel && threadDate) {\n      const emailAgeDays = (Date.now() - threadDate.getTime()) / (1000 * 60 * 60 * 24);\n      if (emailAgeDays <= maxRetention) {\n        stats.preservedByKeepDaysActive++;\n        preserved.push({ subject: threadSubject.substring(0, 60), reason: `${retentionLabel} (${Math.round(emailAgeDays)}/${maxRetention}d)` });\n        continue;\n      }\n    }\n\n    // Thread is eligible for deletion\n    toDelete.push({ id: threadId, subject: threadSubject.substring(0, 60) });\n\n  } catch (e) {\n    stats.errors++;\n    errors.push(`Thread ${threadId}: ${e.message}`);\n  }\n}\n\n// ============================================================\n// PHASE 6: Execute deletions (live mode only)\n// ============================================================\nif (mode === 'live' && toDelete.length > 0) {\n  for (const thread of toDelete) {\n    try {\n      await apiRequest.call(this, `https://gmail.googleapis.com/gmail/v1/users/me/threads/${thread.id}/trash`, 'POST');\n      stats.threadsDeleted++;\n    } catch (e) {\n      stats.errors++;\n      errors.push(`Trash ${thread.id}: ${e.message}`);\n    }\n  }\n}\n\n// ============================================================\n// PHASE 7: Build report\n// ============================================================\nlet report = `Gmail Cleanup Report (${mode.toUpperCase()})\\n`;\nreport += `Days threshold: ${daysThreshold}, Keep label: ${keepLabel}\\n`;\nreport += `Keeper contacts: ${keeperEmails.size} emails\\n`;\nreport += `KEEP_* labels: ${Object.keys(keepDaysLabels).length} (${Object.entries(keepDaysLabels).map(([k,v]) => `${k}=${v}d`).join(', ') || 'none'})\\n`;\nreport += `Search query: ${searchQuery.substring(0, 200)}${searchQuery.length > 200 ? '...' : ''}\\n\\n`;\n\nreport += `Results:\\n`;\nreport += `  Threads scanned: ${stats.threadsScanned}\\n`;\n\nif (mode === 'live') {\n  report += `  Threads TRASHED: ${stats.threadsDeleted}\\n`;\n} else {\n  report += `  Threads to delete: ${toDelete.length}\\n`;\n}\n\nreport += `  Preserved by KEEP label: ${stats.preservedByKeepLabel}\\n`;\nreport += `  Preserved by keeper contact: ${stats.preservedByContact}\\n`;\nreport += `  Preserved by KEEP_* retention: ${stats.preservedByKeepDaysActive}\\n`;\n\nif (stats.errors > 0) {\n  report += `  Errors: ${stats.errors}\\n`;\n}\n\nif (toDelete.length > 0) {\n  const action = mode === 'live' ? 'Trashed' : 'Would delete';\n  report += `\\n${action} threads (${Math.min(toDelete.length, 20)} of ${toDelete.length}):\\n`;\n  for (const t of toDelete.slice(0, 20)) {\n    report += `  - ${t.subject || '(no subject)'}\\n`;\n  }\n  if (toDelete.length > 20) {\n    report += `  ... and ${toDelete.length - 20} more\\n`;\n  }\n}\n\nif (errors.length > 0) {\n  report += `\\nErrors:\\n`;\n  for (const e of errors.slice(0, 10)) {\n    report += `  - ${e}\\n`;\n  }\n}\n\nreturn [{ json: { report, mode, stats } }];"
      },
      "id": "cleanup-code",
      "name": "Code: Gmail Cleanup",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        640,
        640
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.GOTIFY_URL }}/message",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Gotify-Key",
              "value": "={{ $env.GOTIFY_TOKEN }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ title: 'Gmail Cleanup', message: $json.report, priority: $json.mode === 'live' ? 5 : 3 }) }}",
        "options": {}
      },
      "id": "gotify-notify",
      "name": "Notify via Gotify",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1020,
        360
      ]
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        176,
        640
      ],
      "id": "660ec14c-0bdc-4983-918e-41f7fdbe57b8",
      "name": "When clicking \u2018Execute workflow\u2019"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": ""
          },
          "conditions": [
            {
              "id": "errors-check",
              "leftValue": "={{ $json.stats.errors }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-errors",
      "name": "Has Errors?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        840,
        420
      ]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          },
          {
            "node": "Set Webhook Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run": {
      "main": [
        [
          {
            "node": "Respond Dry Run",
            "type": "main",
            "index": 0
          },
          {
            "node": "Set Dry Run Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Live Run": {
      "main": [
        [
          {
            "node": "Respond Live Run",
            "type": "main",
            "index": 0
          },
          {
            "node": "Set Live Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Webhook Config": {
      "main": [
        [
          {
            "node": "Code: Gmail Cleanup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Dry Run Config": {
      "main": [
        [
          {
            "node": "Code: Gmail Cleanup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Live Config": {
      "main": [
        [
          {
            "node": "Code: Gmail Cleanup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code: Gmail Cleanup": {
      "main": [
        [
          {
            "node": "Has Errors?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking \u2018Execute workflow\u2019": {
      "main": [
        [
          {
            "node": "Set Dry Run Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Errors?": {
      "main": [
        [
          {
            "node": "Notify via Gotify",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  }
}
