{
  "name": "Gmail Labels & Contacts",
  "description": "Lists all Gmail labels with message counts and keeper contact group members. Returns JSON for Homepage widget + sends Gotify report. Webhook: /webhook/gmail-labels-contacts",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "gmail-labels-contacts",
        "responseMode": "responseNode"
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        220,
        300
      ],
      "webhookId": "gmail-labels-contacts"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "a1",
              "name": "googleClientId",
              "value": "={{ $env.GOOGLE_CLIENT_ID }}",
              "type": "string"
            },
            {
              "id": "a2",
              "name": "googleClientSecret",
              "value": "={{ $env.GOOGLE_CLIENT_SECRET }}",
              "type": "string"
            },
            {
              "id": "a3",
              "name": "googleRefreshToken",
              "value": "={{ $env.GOOGLE_REFRESH_TOKEN }}",
              "type": "string"
            }
          ]
        }
      },
      "id": "set-creds",
      "name": "Set Credentials",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        440,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Gmail Labels & Contacts - Discovery/Reporting Tool\n// Lists all labels with message counts and keeper contact group members\n// Returns both structured JSON (for Homepage widget) and text report (for Gotify)\n\nconst items = $input.all();\nconst { googleClientId, googleClientSecret, googleRefreshToken } = items[0].json;\n\n// Get OAuth2 access token\nconst tokenBody = `client_id=${encodeURIComponent(googleClientId)}&client_secret=${encodeURIComponent(googleClientSecret)}&refresh_token=${encodeURIComponent(googleRefreshToken)}&grant_type=refresh_token`;\nconst tokenResp = await this.helpers.httpRequest({\n  method: 'POST',\n  url: 'https://oauth2.googleapis.com/token',\n  body: tokenBody,\n  headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n});\nconst accessToken = tokenResp.access_token;\n\nasync function apiRequest(url, method = 'GET') {\n  return await this.helpers.httpRequest({\n    method,\n    url,\n    headers: { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' }\n  });\n}\n\nfunction parseKeepDaysLabel(labelName) {\n  const match = labelName.match(/^KEEP_(\\d{1,3})(D|W|M)$/i);\n  if (!match) return null;\n  const value = parseInt(match[1], 10);\n  const unit = match[2].toLowerCase();\n  const multipliers = { d: 1, w: 7, m: 30 };\n  const days = value * (multipliers[unit] || 1);\n  return (days >= 1 && days <= 3650) ? days : null;\n}\n\nconst errors = [];\n\n// PHASE 1: Fetch all labels with message counts\nconst labelsResp = await apiRequest.call(this, 'https://gmail.googleapis.com/gmail/v1/users/me/labels');\nconst allLabels = labelsResp.labels || [];\n\nconst userLabels = [];\nconst systemLabels = [];\nconst keepLabels = [];\nlet inboxUnread = 0;\nlet inboxTotal = 0;\n\nfor (const label of allLabels) {\n  try {\n    const detail = await apiRequest.call(this, `https://gmail.googleapis.com/gmail/v1/users/me/labels/${label.id}`);\n    const info = {\n      name: detail.name,\n      id: detail.id,\n      type: detail.type,\n      messagesTotal: detail.messagesTotal || 0,\n      messagesUnread: detail.messagesUnread || 0,\n      threadsTotal: detail.threadsTotal || 0,\n      threadsUnread: detail.threadsUnread || 0,\n    };\n    \n    if (detail.name === 'INBOX') {\n      inboxUnread = info.messagesUnread;\n      inboxTotal = info.messagesTotal;\n    }\n    \n    if (detail.type === 'system') {\n      systemLabels.push(info);\n    } else {\n      userLabels.push(info);\n    }\n    \n    if (detail.name.toUpperCase() === 'KEEP' || parseKeepDaysLabel(detail.name) !== null) {\n      const retDays = parseKeepDaysLabel(detail.name);\n      keepLabels.push({\n        name: detail.name,\n        retention: retDays ? `${retDays} days` : 'forever',\n        messagesTotal: info.messagesTotal,\n        threadsTotal: info.threadsTotal,\n      });\n    }\n  } catch (e) {\n    errors.push(`Label ${label.name}: ${e.message}`);\n  }\n}\n\nuserLabels.sort((a, b) => a.name.localeCompare(b.name));\nsystemLabels.sort((a, b) => a.name.localeCompare(b.name));\n\n// PHASE 2: Fetch keeper contacts\nlet keeperContactInfo = [];\nlet keeperGroupName = null;\n\ntry {\n  const groupsResp = await apiRequest.call(this, 'https://people.googleapis.com/v1/contactGroups?pageSize=1000');\n  const contactGroups = (groupsResp.contactGroups || []).filter(g => g.groupType === 'USER_CONTACT_GROUP');\n  const keeperGroup = contactGroups.find(g => g.name.toLowerCase() === 'keeper');\n  \n  if (keeperGroup) {\n    keeperGroupName = keeperGroup.name;\n    const groupDetail = await apiRequest.call(this, `https://people.googleapis.com/v1/${keeperGroup.resourceName}?maxMembers=1000`);\n    const memberResourceNames = groupDetail.memberResourceNames || [];\n    \n    if (memberResourceNames.length > 0) {\n      for (let i = 0; i < memberResourceNames.length; i += 50) {\n        const batch = memberResourceNames.slice(i, i + 50);\n        const params = batch.map(r => `resourceNames=${encodeURIComponent(r)}`).join('&');\n        const peopleResp = await apiRequest.call(this, `https://people.googleapis.com/v1/people:batchGet?${params}&personFields=emailAddresses,names`);\n        \n        for (const resp of (peopleResp.responses || [])) {\n          const person = resp.person || {};\n          const names = (person.names || []).map(n => n.displayName).filter(Boolean);\n          const emails = (person.emailAddresses || []).map(e => e.value).filter(Boolean);\n          if (emails.length > 0) {\n            keeperContactInfo.push({\n              name: names[0] || '(no name)',\n              emails: emails.map(e => e.toLowerCase()),\n            });\n          }\n        }\n      }\n    }\n  }\n} catch (e) {\n  errors.push(`Contacts API: ${e.message}`);\n}\n\nkeeperContactInfo.sort((a, b) => a.name.localeCompare(b.name));\n\n// PHASE 3: Build text report (for Gotify)\nconst totalLabels = allLabels.length;\nlet report = `Gmail Labels & Contacts Report\\n\\n`;\n\nif (keepLabels.length > 0) {\n  report += `KEEP Labels (${keepLabels.length}):\\n`;\n  for (const kl of keepLabels) {\n    report += `  ${kl.name} - ${kl.retention}, ${kl.threadsTotal.toLocaleString()} threads, ${kl.messagesTotal.toLocaleString()} msgs\\n`;\n  }\n  report += `\\n`;\n}\n\nreport += `User Labels (${userLabels.length}):\\n`;\nfor (const l of userLabels) {\n  const unread = l.messagesUnread > 0 ? `, ${l.messagesUnread.toLocaleString()} unread` : '';\n  report += `  ${l.name} (${l.messagesTotal.toLocaleString()} msgs${unread})\\n`;\n}\nreport += `\\n`;\n\nreport += `System Labels (${systemLabels.length}):\\n`;\nconst activeSysLabels = systemLabels.filter(l => l.messagesTotal > 0);\nfor (const l of activeSysLabels) {\n  const unread = l.messagesUnread > 0 ? `, ${l.messagesUnread.toLocaleString()} unread` : '';\n  report += `  ${l.name} (${l.messagesTotal.toLocaleString()} msgs${unread})\\n`;\n}\nif (systemLabels.length > activeSysLabels.length) {\n  report += `  ... and ${systemLabels.length - activeSysLabels.length} empty system labels\\n`;\n}\nreport += `\\n`;\n\nif (keeperGroupName) {\n  const totalEmails = keeperContactInfo.reduce((sum, c) => sum + c.emails.length, 0);\n  report += `Keeper Contacts (\"${keeperGroupName}\" group, ${keeperContactInfo.length} members, ${totalEmails} emails):\\n`;\n  for (const c of keeperContactInfo) {\n    report += `  ${c.name}: ${c.emails.join(', ')}\\n`;\n  }\n} else {\n  report += `Keeper Contacts: No \"keeper\" contact group found\\n`;\n}\n\nif (errors.length > 0) {\n  report += `\\nErrors:\\n`;\n  for (const e of errors) {\n    report += `  - ${e}\\n`;\n  }\n}\n\nreport += `\\nTotal: ${totalLabels} labels (${userLabels.length} user, ${systemLabels.length} system)`;\n\n// PHASE 4: Build structured data (for Homepage widget)\nconst keepThreadsTotal = keepLabels.reduce((sum, kl) => sum + kl.threadsTotal, 0);\n\nreturn [{ json: {\n  report,\n  inboxUnread,\n  inboxTotal,\n  totalLabels,\n  userLabels: userLabels.length,\n  keepLabels: keepLabels.length,\n  keepThreads: keepThreadsTotal,\n  keeperContacts: keeperContactInfo.length,\n  errors: errors.length\n} }];"
      },
      "id": "labels-contacts-code",
      "name": "Code: Fetch Labels & Contacts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        660,
        300
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ inboxUnread: $json.inboxUnread, inboxTotal: $json.inboxTotal, totalLabels: $json.totalLabels, userLabels: $json.userLabels, keepLabels: $json.keepLabels, keepThreads: $json.keepThreads, keeperContacts: $json.keeperContacts }) }}"
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        880,
        200
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.GOTIFY_URL }}/message",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Gotify-Key",
              "value": "={{ $env.GOTIFY_TOKEN }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ title: 'Gmail Labels & Contacts', message: $json.report, priority: 3 }) }}"
      },
      "id": "gotify-notify",
      "name": "Notify via Gotify",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        880,
        400
      ]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Set Credentials",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Credentials": {
      "main": [
        [
          {
            "node": "Code: Fetch Labels & Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code: Fetch Labels & Contacts": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          },
          {
            "node": "Notify via Gotify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  }
}
