{
  "name": "Daily Network Summary",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 8 * * *"
            }
          ]
        }
      },
      "id": "nds-trigger",
      "name": "Daily 8:00 AM",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [0, 300]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            { "id": "e1", "name": "UNIFI_URL", "value": "={{ $env.UNIFI_URL }}", "type": "string" },
            { "id": "e2", "name": "UNIFI_USERNAME", "value": "={{ $env.UNIFI_USERNAME }}", "type": "string" },
            { "id": "e3", "name": "UNIFI_PASSWORD", "value": "={{ $env.UNIFI_PASSWORD }}", "type": "string" },
            { "id": "e4", "name": "DISCORD_WEBHOOK_URL", "value": "={{ $env.DISCORD_WEBHOOK_URL }}", "type": "string" }
          ]
        }
      },
      "id": "nds-set-env",
      "name": "Set Env Vars",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [220, 300]
    },
    {
      "parameters": {
        "jsCode": "const env = $input.first().json;\nconst UNIFI_URL = env.UNIFI_URL;\nconst UNIFI_USERNAME = env.UNIFI_USERNAME;\nconst UNIFI_PASSWORD = env.UNIFI_PASSWORD;\nconst httpRequest = this.helpers.httpRequest.bind(this.helpers);\n\nfunction formatUptime(seconds) {\n  const d = Math.floor(seconds / 86400);\n  const h = Math.floor((seconds % 86400) / 3600);\n  if (d > 0) return `${d}d ${h}h`;\n  return `${h}h`;\n}\n\nconst fields = [];\n\ntry {\n  // 1. Authenticate to UniFi\n  const loginResp = await httpRequest({\n    method: 'POST',\n    url: `${UNIFI_URL}/api/auth/login`,\n    body: { username: UNIFI_USERNAME, password: UNIFI_PASSWORD },\n    returnFullResponse: true,\n    skipSslCertificateValidation: true,\n    json: true\n  });\n\n  const rawCookies = loginResp.headers['set-cookie'];\n  let cookieStr = '';\n  if (Array.isArray(rawCookies)) {\n    cookieStr = rawCookies.map(c => c.split(';')[0]).join('; ');\n  } else if (typeof rawCookies === 'string') {\n    cookieStr = rawCookies.split(';')[0];\n  }\n\n  async function unifiGet(path) {\n    const raw = await httpRequest({\n      url: `${UNIFI_URL}${path}`,\n      headers: { Cookie: cookieStr },\n      skipSslCertificateValidation: true\n    });\n    return typeof raw === 'string' ? JSON.parse(raw) : raw;\n  }\n\n  // 2. WAN Health & Gateway\n  const healthResp = await unifiGet('/proxy/network/api/s/default/stat/health');\n  const subsystems = healthResp.data || [];\n  const wan = subsystems.find(s => s.subsystem === 'wan');\n  const www = subsystems.find(s => s.subsystem === 'www');\n\n  if (wan) {\n    const gwStats = wan['gw_system-stats'] || {};\n    const gwUptime = formatUptime(parseInt(gwStats.uptime || 0));\n    const gwCpu = parseFloat(gwStats.cpu || 0).toFixed(0);\n    const gwMem = parseFloat(gwStats.mem || 0).toFixed(0);\n    const ispName = wan.isp_name || 'Unknown';\n\n    // WAN1 info\n    const uptimeStats = wan.uptime_stats || {};\n    const wan1Stats = uptimeStats.WAN || {};\n    const wan1Latency = wan1Stats.latency_average || 0;\n    fields.push({\n      name: `\\ud83c\\udf10 WAN (${ispName})`,\n      value: `IP: ${wan.wan_ip || 'N/A'} | Latency: ${wan1Latency}ms | Status: ${wan.status}`,\n      inline: false\n    });\n\n    // WAN2 info\n    const wan2Stats = uptimeStats.WAN2;\n    if (wan2Stats) {\n      const wan2Latency = wan2Stats.latency_average || 0;\n      fields.push({\n        name: '\\ud83c\\udf10 WAN2 (T-Mobile)',\n        value: `Latency: ${wan2Latency}ms | Status: ok`,\n        inline: false\n      });\n    }\n\n    // Gateway\n    fields.push({\n      name: `\\ud83d\\udda5\\ufe0f ${wan.gw_name || 'Gateway'}`,\n      value: `CPU: ${gwCpu}% | Mem: ${gwMem}% | Up: ${gwUptime} | FW: ${wan.gw_version || 'N/A'}`,\n      inline: false\n    });\n  }\n\n  // 3. Speedtest results\n  const speedResp = await unifiGet('/proxy/network/v2/api/site/default/speedtest');\n  const speedResults = speedResp.data || [];\n  const latestByWan = {};\n  for (const r of speedResults) {\n    const ng = r.wan_networkgroup;\n    if (!ng || r.download_mbps === 0) continue;\n    if (!latestByWan[ng] || r.time > latestByWan[ng].time) latestByWan[ng] = r;\n  }\n  const speedParts = [];\n  if (latestByWan.WAN) {\n    const s = latestByWan.WAN;\n    speedParts.push(`WAN: ${s.download_mbps}\\u2193/${s.upload_mbps}\\u2191 Mbps (${s.latency_ms}ms)`);\n  }\n  if (latestByWan.WAN2) {\n    const s = latestByWan.WAN2;\n    speedParts.push(`WAN2: ${s.download_mbps}\\u2193/${s.upload_mbps}\\u2191 Mbps (${s.latency_ms}ms)`);\n  }\n  if (speedParts.length > 0) {\n    fields.push({\n      name: '\\ud83d\\udcc8 Last Speedtest',\n      value: speedParts.join(' | '),\n      inline: false\n    });\n  }\n\n  // 4. Devices\n  const devResp = await unifiGet('/proxy/network/api/s/default/stat/device');\n  const devices = devResp.data || [];\n  const aps = devices.filter(d => d.type === 'uap');\n  const switches = devices.filter(d => d.type === 'usw' || d.type === 'udb');\n  const apsOnline = aps.filter(d => d.state === 1).length;\n  const swOnline = switches.filter(d => d.state === 1).length;\n\n  // 5. WiFi clients\n  const staResp = await unifiGet('/proxy/network/api/s/default/stat/sta');\n  const clients = staResp.data || [];\n  const sats = clients.filter(c => c.satisfaction !== undefined).map(c => c.satisfaction);\n  const avgSat = sats.length > 0 ? Math.round(sats.reduce((a, b) => a + b, 0) / sats.length) : 0;\n  const poorSat = sats.filter(s => s < 50).length;\n  const weakSignal = clients.filter(c => c.signal !== undefined && c.signal < -80).length;\n\n  fields.push({\n    name: '\\ud83d\\udce1 Devices & Clients',\n    value: `${apsOnline}/${aps.length} APs | ${swOnline}/${switches.length} switches | ${clients.length} WiFi clients | Avg satisfaction: ${avgSat}%${poorSat > 0 ? ` | ${poorSat} poor` : ''}${weakSignal > 0 ? ` | ${weakSignal} weak signal` : ''}`,\n    inline: false\n  });\n\n} catch (err) {\n  fields.push({ name: '\\u274c Error', value: `UniFi API: ${err.message}`, inline: false });\n}\n\nreturn [{ json: { unifiFields: fields } }];"
      },
      "id": "nds-unifi",
      "name": "Gather UniFi Stats",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 300]
    },
    {
      "parameters": {
        "resource": "command",
        "operation": "execute",
        "command": "docker ps -a --filter name=cloudflare --format json | jq -r '[.Names, .State, .Status] | join(\"|\")'",
        "authentication": "privateKey",
        "options": {}
      },
      "id": "nds-ssh-cadre",
      "name": "SSH cadre tunnels",
      "type": "n8n-nodes-base.ssh",
      "typeVersion": 1,
      "position": [440, 100],
      "onError": "continueRegularOutput",
      "credentials": {
        "sshPrivateKey": {
          "id": "H1zhHsKxDwEDOSRk",
          "name": "cadre SSH"
        }
      }
    },
    {
      "parameters": {
        "resource": "command",
        "operation": "execute",
        "command": "docker ps -a --filter name=cloudflare --format json | jq -r '[.Names, .State, .Status] | join(\"|\")'",
        "authentication": "privateKey",
        "options": {}
      },
      "id": "nds-ssh-utilities",
      "name": "SSH utilities tunnels",
      "type": "n8n-nodes-base.ssh",
      "typeVersion": 1,
      "position": [440, 500],
      "onError": "continueRegularOutput",
      "credentials": {
        "sshPrivateKey": {
          "id": "n8816WsRbTEbFnjD",
          "name": "utilities SSH"
        }
      }
    },
    {
      "parameters": {
        "mode": "append",
        "numberInputs": 3,
        "options": {}
      },
      "id": "nds-merge",
      "name": "Merge Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [660, 300]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\n// Collect UniFi fields\nlet fields = [];\nfor (const item of items) {\n  if (item.json.unifiFields) {\n    fields = fields.concat(item.json.unifiFields);\n  }\n}\n\n// Process SSH tunnel results\nconst expectedTunnels = [\n  'cloudflare-plex',\n  'cloudflare-overseerr',\n  'cloudflared-gotify',\n  'cloudflare-dockhand'\n];\nconst foundTunnels = {};\n\nfor (const item of items) {\n  const stdout = item.json.stdout;\n  if (stdout === undefined) continue;\n  const lines = stdout.trim().split('\\n').filter(l => l.length > 0);\n  for (const line of lines) {\n    const parts = line.split('|');\n    const name = (parts[0] || '').trim();\n    const state = (parts[1] || '').trim();\n    const status = (parts[2] || '').trim();\n    if (name) foundTunnels[name] = { state, status };\n  }\n}\n\nconst tunnelParts = [];\nlet tunnelsRunning = 0;\nfor (const tunnel of expectedTunnels) {\n  const info = foundTunnels[tunnel];\n  const shortName = tunnel.replace('cloudflare-', '').replace('cloudflared-', '');\n  if (info && info.state === 'running') {\n    tunnelsRunning++;\n    tunnelParts.push(shortName);\n  } else {\n    tunnelParts.push(`**${shortName}** (DOWN)`);\n  }\n}\n\nfields.push({\n  name: '\\u2601\\ufe0f Cloudflare Tunnels',\n  value: `${tunnelsRunning}/${expectedTunnels.length} running (${tunnelParts.join(', ')})`,\n  inline: false\n});\n\nconst today = new Date().toLocaleDateString('en-US', {\n  year: 'numeric', month: 'short', day: 'numeric', timeZone: 'America/New_York'\n});\n\nreturn [{\n  json: {\n    title: `\\ud83d\\udce1 Daily Network Report \\u2014 ${today}`,\n    color: 3447003,\n    fields,\n    footer: 'Gateway: Cloud Gateway Max | Primary: Metronet | Backup: T-Mobile',\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "nds-format",
      "name": "Format Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [880, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Set Env Vars').first().json.DISCORD_WEBHOOK_URL }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ embeds: [{ title: $json.title, color: $json.color, fields: $json.fields, footer: { text: $json.footer }, timestamp: $json.timestamp }] }) }}",
        "options": {}
      },
      "id": "nds-discord",
      "name": "Discord Summary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1100, 300]
    }
  ],
  "connections": {
    "Daily 8:00 AM": {
      "main": [[{ "node": "Set Env Vars", "type": "main", "index": 0 }]]
    },
    "Set Env Vars": {
      "main": [[
        { "node": "Gather UniFi Stats", "type": "main", "index": 0 },
        { "node": "SSH cadre tunnels", "type": "main", "index": 0 },
        { "node": "SSH utilities tunnels", "type": "main", "index": 0 }
      ]]
    },
    "Gather UniFi Stats": {
      "main": [[{ "node": "Merge Results", "type": "main", "index": 0 }]]
    },
    "SSH cadre tunnels": {
      "main": [[{ "node": "Merge Results", "type": "main", "index": 1 }]]
    },
    "SSH utilities tunnels": {
      "main": [[{ "node": "Merge Results", "type": "main", "index": 2 }]]
    },
    "Merge Results": {
      "main": [[{ "node": "Format Summary", "type": "main", "index": 0 }]]
    },
    "Format Summary": {
      "main": [[{ "node": "Discord Summary", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  }
}
