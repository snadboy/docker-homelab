{
  "name": "Daily Homelab Report",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "15 8 * * *"
            }
          ]
        }
      },
      "id": "dhr-trigger",
      "name": "Daily 8:15 AM",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        0,
        300
      ]
    },
    {
      "parameters": {
        "putAllInOneKey": false
      },
      "id": "dhr-globals",
      "name": "Globals",
      "type": "n8n-nodes-globals.globalConstants",
      "typeVersion": 1,
      "position": [
        220,
        300
      ],
      "credentials": {
        "globalConstantsApi": {
          "id": "kt9rQnvdyaBeZlR2",
          "name": "Homelab Constants"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const globals = $('Globals').first().json;\nconst UNIFI_URL = globals.UNIFI_URL;\nconst UNIFI_USERNAME = globals.UNIFI_USERNAME;\nconst UNIFI_PASSWORD = globals.UNIFI_PASSWORD;\nconst httpRequest = this.helpers.httpRequest.bind(this.helpers);\n\nfunction formatUptime(seconds) {\n  const d = Math.floor(seconds / 86400);\n  const h = Math.floor((seconds % 86400) / 3600);\n  if (d > 0) return `${d}d ${h}h`;\n  return `${h}h`;\n}\n\nconst parts = [];\n\ntry {\n  // 1. Authenticate to UniFi\n  const loginResp = await httpRequest({\n    method: 'POST',\n    url: `${UNIFI_URL}/api/auth/login`,\n    body: { username: UNIFI_USERNAME, password: UNIFI_PASSWORD },\n    returnFullResponse: true,\n    skipSslCertificateValidation: true,\n    json: true\n  });\n\n  const rawCookies = loginResp.headers['set-cookie'];\n  let cookieStr = '';\n  if (Array.isArray(rawCookies)) {\n    cookieStr = rawCookies.map(c => c.split(';')[0]).join('; ');\n  } else if (typeof rawCookies === 'string') {\n    cookieStr = rawCookies.split(';')[0];\n  }\n\n  async function unifiGet(path) {\n    const raw = await httpRequest({\n      url: `${UNIFI_URL}${path}`,\n      headers: { Cookie: cookieStr },\n      skipSslCertificateValidation: true\n    });\n    return typeof raw === 'string' ? JSON.parse(raw) : raw;\n  }\n\n  // 2. WAN Health & Gateway\n  const healthResp = await unifiGet('/proxy/network/api/s/default/stat/health');\n  const subsystems = healthResp.data || [];\n  const wan = subsystems.find(s => s.subsystem === 'wan');\n\n  if (wan) {\n    const gwStats = wan['gw_system-stats'] || {};\n    const gwUptime = formatUptime(parseInt(gwStats.uptime || 0));\n    const gwCpu = parseFloat(gwStats.cpu || 0).toFixed(0);\n    const gwMem = parseFloat(gwStats.mem || 0).toFixed(0);\n    const ispName = wan.isp_name || 'Unknown';\n\n    const uptimeStats = wan.uptime_stats || {};\n    const wan1Stats = uptimeStats.WAN || {};\n    const wan1Latency = wan1Stats.latency_average || 0;\n    parts.push(`**\\u{1f310} WAN (${ispName})**\\nIP: ${wan.wan_ip || 'N/A'} | Latency: ${wan1Latency}ms | Status: ${wan.status}`);\n\n    const wan2Stats = uptimeStats.WAN2;\n    if (wan2Stats) {\n      const wan2Latency = wan2Stats.latency_average || 0;\n      parts.push(`**\\u{1f310} WAN2 (T-Mobile)**\\nLatency: ${wan2Latency}ms | Status: ok`);\n    }\n\n    parts.push(`**\\u{1f5a5}\\ufe0f ${wan.gw_name || 'Gateway'}**\\nCPU: ${gwCpu}% | Mem: ${gwMem}% | Up: ${gwUptime} | FW: ${wan.gw_version || 'N/A'}`);\n  }\n\n  // 3. Speedtest results\n  const speedResp = await unifiGet('/proxy/network/v2/api/site/default/speedtest');\n  const speedResults = speedResp.data || [];\n  const latestByWan = {};\n  for (const r of speedResults) {\n    const ng = r.wan_networkgroup;\n    if (!ng || r.download_mbps === 0) continue;\n    if (!latestByWan[ng] || r.time > latestByWan[ng].time) latestByWan[ng] = r;\n  }\n  const speedParts = [];\n  if (latestByWan.WAN) {\n    const s = latestByWan.WAN;\n    speedParts.push(`WAN: ${s.download_mbps}\\u2193/${s.upload_mbps}\\u2191 Mbps (${s.latency_ms}ms)`);\n  }\n  if (latestByWan.WAN2) {\n    const s = latestByWan.WAN2;\n    speedParts.push(`WAN2: ${s.download_mbps}\\u2193/${s.upload_mbps}\\u2191 Mbps (${s.latency_ms}ms)`);\n  }\n  if (speedParts.length > 0) {\n    parts.push(`**\\u{1f4c8} Last Speedtest**\\n${speedParts.join(' | ')}`);\n  }\n\n  // 4. Devices\n  const devResp = await unifiGet('/proxy/network/api/s/default/stat/device');\n  const devices = devResp.data || [];\n  const aps = devices.filter(d => d.type === 'uap');\n  const switches = devices.filter(d => d.type === 'usw' || d.type === 'udb');\n  const apsOnline = aps.filter(d => d.state === 1).length;\n  const swOnline = switches.filter(d => d.state === 1).length;\n\n  // 5. WiFi clients\n  const staResp = await unifiGet('/proxy/network/api/s/default/stat/sta');\n  const clients = staResp.data || [];\n  const sats = clients.filter(c => c.satisfaction !== undefined).map(c => c.satisfaction);\n  const avgSat = sats.length > 0 ? Math.round(sats.reduce((a, b) => a + b, 0) / sats.length) : 0;\n  const poorSat = sats.filter(s => s < 50).length;\n  const weakSignal = clients.filter(c => c.signal !== undefined && c.signal < -80).length;\n\n  parts.push(`**\\u{1f4e1} Devices & Clients**\\n${apsOnline}/${aps.length} APs | ${swOnline}/${switches.length} switches | ${clients.length} WiFi clients | Avg satisfaction: ${avgSat}%${poorSat > 0 ? ` | ${poorSat} poor` : ''}${weakSignal > 0 ? ` | ${weakSignal} weak signal` : ''}`);\n\n} catch (err) {\n  parts.push(`**\\u274c Error**\\nUniFi API: ${err.message}`);\n}\n\nreturn [{ json: { unifiDesc: parts.join('\\n\\n') } }];"
      },
      "id": "dhr-unifi",
      "name": "Gather UniFi Stats",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        440,
        300
      ]
    },
    {
      "parameters": {
        "resource": "command",
        "operation": "execute",
        "command": "docker ps -a --filter name=cloudflare --format json | jq -r '[.Names, .State, .Status] | join(\"|\")'",
        "authentication": "privateKey",
        "options": {}
      },
      "id": "dhr-ssh-cadre",
      "name": "SSH cadre tunnels",
      "type": "n8n-nodes-base.ssh",
      "typeVersion": 1,
      "position": [
        440,
        100
      ],
      "onError": "continueRegularOutput",
      "credentials": {
        "sshPrivateKey": {
          "id": "H1zhHsKxDwEDOSRk",
          "name": "cadre SSH"
        }
      }
    },
    {
      "parameters": {
        "resource": "command",
        "operation": "execute",
        "command": "docker ps -a --filter name=cloudflare --format json | jq -r '[.Names, .State, .Status] | join(\"|\")'",
        "authentication": "privateKey",
        "options": {}
      },
      "id": "dhr-ssh-utilities",
      "name": "SSH utilities tunnels",
      "type": "n8n-nodes-base.ssh",
      "typeVersion": 1,
      "position": [
        440,
        500
      ],
      "onError": "continueRegularOutput",
      "credentials": {
        "sshPrivateKey": {
          "id": "n8816WsRbTEbFnjD",
          "name": "utilities SSH"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const globals = $('Globals').first().json;\nconst PVE = globals.PVE_API_URL;\nconst TOKEN = globals.PVE_API_TOKEN;\nconst headers = { Authorization: `PVEAPIToken=${TOKEN}` };\nconst opts = { method: 'GET', headers, skipSslCertificateValidation: true, timeout: 15000 };\n\nfunction formatUptime(seconds) {\n  const d = Math.floor(seconds / 86400);\n  const h = Math.floor((seconds % 86400) / 3600);\n  if (d > 0) return `${d}d ${h}h`;\n  return `${h}h`;\n}\n\nfunction formatBytes(bytes) {\n  const gb = bytes / (1024 * 1024 * 1024);\n  if (gb >= 1024) return `${(gb / 1024).toFixed(1)} TB`;\n  return `${gb.toFixed(1)} GB`;\n}\n\nconst parts = [];\nlet totalVmsRunning = 0, totalVmsTotal = 0;\nlet totalCtsRunning = 0, totalCtsTotal = 0;\nlet nodesOnline = 0;\n\ntry {\n  const nodesResp = await this.helpers.httpRequest({ ...opts, url: `${PVE}/api2/json/nodes` });\n  const nodes = (nodesResp.data || []).sort((a, b) => a.node.localeCompare(b.node));\n\n  for (const node of nodes) {\n    const name = node.node;\n\n    if (node.status !== 'online') {\n      parts.push(`\\u{1f534} **${name}** \\u2014 OFFLINE`);\n      continue;\n    }\n    nodesOnline++;\n\n    const cpuPct = Math.round(node.cpu * 100);\n    const memPct = Math.round((node.mem / node.maxmem) * 100);\n    const diskPct = Math.round((node.disk / node.maxdisk) * 100);\n    const uptime = formatUptime(node.uptime);\n\n    let vmRunning = 0, vmTotal = 0, ctRunning = 0, ctTotal = 0;\n\n    for (const guestType of ['qemu', 'lxc']) {\n      try {\n        const resp = await this.helpers.httpRequest({ ...opts, url: `${PVE}/api2/json/nodes/${name}/${guestType}` });\n        const guests = resp.data || [];\n        for (const g of guests) {\n          if (g.template) continue;\n          if (guestType === 'qemu') {\n            vmTotal++;\n            totalVmsTotal++;\n            if (g.status === 'running') { vmRunning++; totalVmsRunning++; }\n          } else {\n            ctTotal++;\n            totalCtsTotal++;\n            if (g.status === 'running') { ctRunning++; totalCtsRunning++; }\n          }\n        }\n      } catch (e) { /* skip */ }\n    }\n\n    const memUsed = formatBytes(node.mem);\n    const memMax = formatBytes(node.maxmem);\n    const guestStr = [];\n    if (vmTotal > 0) guestStr.push(`VMs: ${vmRunning}/${vmTotal}`);\n    if (ctTotal > 0) guestStr.push(`CTs: ${ctRunning}/${ctTotal}`);\n\n    parts.push(`**\\u{1f5a5}\\ufe0f ${name}**\\nCPU: ${cpuPct}% | Mem: ${memPct}% (${memUsed}/${memMax}) | Disk: ${diskPct}% | Up: ${uptime} | ${guestStr.join(' | ')}`);\n  }\n} catch (err) {\n  parts.push(`**\\u274c Error**\\nFailed to query Proxmox API: ${err.message}`);\n}\n\nreturn [{\n  json: {\n    pveDesc: parts.join('\\n\\n'),\n    pveFooter: `${nodesOnline} nodes online | ${totalVmsRunning} VMs running | ${totalCtsRunning} CTs running`\n  }\n}];"
      },
      "id": "dhr-pve",
      "name": "Gather PVE Stats",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        440,
        700
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "AM7xbizoMlhMEp8x",
          "mode": "list"
        }
      },
      "id": "dhr-plex-token",
      "name": "Get Plex Token",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.1,
      "position": [
        440,
        900
      ]
    },
    {
      "parameters": {
        "jsCode": "const env = {...$('Globals').first().json, ...$input.first().json};\nconst today = new Date();\nconst startDate = today.toISOString().split('T')[0];\nconst endDate = new Date(today.getTime() + 86400000).toISOString().split('T')[0];\n\nconst sections = [];\n\n// Sonarr - today's calendar\ntry {\n  const sonarrCal = await this.helpers.httpRequest({\n    method: 'GET',\n    url: `${env.SONARR_URL}/api/v3/calendar?start=${startDate}&end=${endDate}`,\n    headers: { 'X-Api-Key': env.SONARR_API_KEY },\n    timeout: 15000\n  });\n  if (sonarrCal.length > 0) {\n    const eps = sonarrCal.map(e => `  \\u2022 ${e.series?.title || 'Unknown'} - S${String(e.seasonNumber).padStart(2,'0')}E${String(e.episodeNumber).padStart(2,'0')} - ${e.title || ''}`);\n    sections.push(`**\\u{1f4fa} Today's Episodes (${sonarrCal.length})**\\n${eps.join('\\n')}`);\n  } else {\n    sections.push('**\\u{1f4fa} No episodes scheduled today**');\n  }\n} catch (err) {\n  sections.push(`**\\u{1f4fa} Sonarr:** Error - ${err.message}`);\n}\n\n// Radarr - queue (downloading)\ntry {\n  const radarrQueue = await this.helpers.httpRequest({\n    method: 'GET',\n    url: `${env.RADARR_URL}/api/v3/queue?pageSize=20`,\n    headers: { 'X-Api-Key': env.RADARR_API_KEY },\n    timeout: 15000\n  });\n  const records = radarrQueue.records || [];\n  if (records.length > 0) {\n    const movies = records.map(r => {\n      const pct = r.sizeleft && r.size ? Math.round((1 - r.sizeleft / r.size) * 100) : 0;\n      return `  \\u2022 ${r.title || 'Unknown'} (${pct}%)`;\n    });\n    sections.push(`**\\u{1f3ac} Radarr Queue (${records.length})**\\n${movies.join('\\n')}`);\n  } else {\n    sections.push('**\\u{1f3ac} Radarr queue is empty**');\n  }\n} catch (err) {\n  sections.push(`**\\u{1f3ac} Radarr:** Error - ${err.message}`);\n}\n\n// SABnzbd - current queue\ntry {\n  const sabQueue = await this.helpers.httpRequest({\n    method: 'GET',\n    url: `${env.SABNZBD_URL}/api?mode=queue&output=json&apikey=${env.SABNZBD_API_KEY}`,\n    timeout: 15000\n  });\n  const queue = sabQueue.queue || {};\n  const slots = queue.slots || [];\n  const speed = queue.speed || '0';\n  if (slots.length > 0) {\n    sections.push(`**\\u2b07\\ufe0f SABnzbd:** ${slots.length} item(s) downloading at ${speed}/s`);\n  } else {\n    sections.push('**\\u2b07\\ufe0f SABnzbd:** Idle');\n  }\n} catch (err) {\n  sections.push(`**\\u2b07\\ufe0f SABnzbd:** Error - ${err.message}`);\n}\n\n// Plex - library stats\ntry {\n  const plexLibs = await this.helpers.httpRequest({\n    method: 'GET',\n    url: `${env.PLEX_URL}/library/sections`,\n    headers: { 'X-Plex-Token': env.PLEX_TOKEN, 'Accept': 'application/json' },\n    timeout: 15000\n  });\n  const dirs = plexLibs?.MediaContainer?.Directory || [];\n  if (dirs.length > 0) {\n    const libs = dirs.map(d => `  \\u2022 ${d.title}: ${d.type}`);\n    sections.push(`**\\u{1f39e}\\ufe0f Plex Libraries**\\n${libs.join('\\n')}`);\n  }\n} catch (err) {\n  sections.push(`**\\u{1f39e}\\ufe0f Plex:** Error - ${err.message}`);\n}\n\n// Overseerr - pending requests\ntry {\n  const requests = await this.helpers.httpRequest({\n    method: 'GET',\n    url: `${env.OVERSEERR_URL}/api/v1/request?take=10&filter=pending`,\n    headers: { 'X-Api-Key': env.OVERSEERR_API_KEY },\n    timeout: 15000\n  });\n  const pending = requests.results || [];\n  if (pending.length > 0) {\n    sections.push(`**\\u{1f4cb} Overseerr:** ${pending.length} pending request(s)`);\n  } else {\n    sections.push('**\\u{1f4cb} Overseerr:** No pending requests');\n  }\n} catch (err) {\n  sections.push(`**\\u{1f4cb} Overseerr:** Error - ${err.message}`);\n}\n\nreturn [{ json: { mediaDesc: sections.join('\\n\\n') } }];"
      },
      "id": "dhr-media",
      "name": "Gather Media Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        660,
        900
      ]
    },
    {
      "parameters": {
        "mode": "append",
        "numberInputs": 5,
        "options": {}
      },
      "id": "dhr-merge",
      "name": "Merge Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        880,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\n// Collect data from merged items\nlet unifiDesc = '';\nlet pveDesc = '';\nlet pveFooter = '';\nlet mediaDesc = '';\n\nfor (const item of items) {\n  if (item.json.unifiDesc) unifiDesc = item.json.unifiDesc;\n  if (item.json.pveDesc) { pveDesc = item.json.pveDesc; pveFooter = item.json.pveFooter; }\n  if (item.json.mediaDesc) mediaDesc = item.json.mediaDesc;\n}\n\n// Process SSH tunnel results\nconst expectedTunnels = [\n  'cloudflare-plex',\n  'cloudflare-overseerr',\n  'cloudflared-gotify',\n  'cloudflare-dockhand'\n];\nconst foundTunnels = {};\n\nfor (const item of items) {\n  const stdout = item.json.stdout;\n  if (stdout === undefined) continue;\n  const lines = stdout.trim().split('\\n').filter(l => l.length > 0);\n  for (const line of lines) {\n    const parts = line.split('|');\n    const name = (parts[0] || '').trim();\n    const state = (parts[1] || '').trim();\n    const status = (parts[2] || '').trim();\n    if (name) foundTunnels[name] = { state, status };\n  }\n}\n\nconst tunnelParts = [];\nlet tunnelsRunning = 0;\nfor (const tunnel of expectedTunnels) {\n  const info = foundTunnels[tunnel];\n  const shortName = tunnel.replace('cloudflare-', '').replace('cloudflared-', '');\n  if (info && info.state === 'running') {\n    tunnelsRunning++;\n    tunnelParts.push(shortName);\n  } else {\n    tunnelParts.push(`**${shortName}** (DOWN)`);\n  }\n}\n\nunifiDesc += `\\n\\n**\\u2601\\ufe0f Cloudflare Tunnels**\\n${tunnelsRunning}/${expectedTunnels.length} running (${tunnelParts.join(', ')})`;\n\nconst today = new Date().toLocaleDateString('en-US', {\n  year: 'numeric', month: 'short', day: 'numeric', timeZone: 'America/New_York'\n});\n\nreturn [{\n  json: {\n    embeds: [\n      {\n        title: `\\u{1f4e1} Network \\u2014 ${today}`,\n        description: unifiDesc,\n        color: 3447003,\n        footer: { text: 'Gateway: Cloud Gateway Max | Primary: Metronet | Backup: T-Mobile' },\n        timestamp: new Date().toISOString()\n      },\n      {\n        title: `\\u{1f5a5}\\ufe0f Proxmox \\u2014 ${today}`,\n        description: pveDesc,\n        color: 3447003,\n        footer: { text: pveFooter },\n        timestamp: new Date().toISOString()\n      },\n      {\n        title: `\\u{1f3ac} Media \\u2014 ${today}`,\n        description: mediaDesc,\n        color: 3447003,\n        timestamp: new Date().toISOString()\n      }\n    ]\n  }\n}];"
      },
      "id": "dhr-format",
      "name": "Format Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        300
      ]
    },
    {
      "parameters": {
        "authentication": "webhook",
        "resource": "webhook",
        "operation": "sendLegacy",
        "content": "",
        "embeds": {
          "values": [
            {
              "inputMethod": "json",
              "json": "={{ JSON.stringify($json.embeds[0]) }}"
            },
            {
              "inputMethod": "json",
              "json": "={{ JSON.stringify($json.embeds[1]) }}"
            },
            {
              "inputMethod": "json",
              "json": "={{ JSON.stringify($json.embeds[2]) }}"
            }
          ]
        },
        "options": {}
      },
      "id": "dhr-discord",
      "name": "Discord Report",
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [
        1320,
        300
      ],
      "credentials": {
        "discordWebhookApi": {
          "id": "2sFNFWT1cJPmliyb",
          "name": "Discord Reports Webhook"
        }
      }
    }
  ],
  "connections": {
    "Daily 8:15 AM": {
      "main": [
        [
          {
            "node": "Globals",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Globals": {
      "main": [
        [
          {
            "node": "Gather UniFi Stats",
            "type": "main",
            "index": 0
          },
          {
            "node": "SSH cadre tunnels",
            "type": "main",
            "index": 0
          },
          {
            "node": "SSH utilities tunnels",
            "type": "main",
            "index": 0
          },
          {
            "node": "Gather PVE Stats",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Plex Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gather UniFi Stats": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SSH cadre tunnels": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "SSH utilities tunnels": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Gather PVE Stats": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Get Plex Token": {
      "main": [
        [
          {
            "node": "Gather Media Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gather Media Data": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Merge Results": {
      "main": [
        [
          {
            "node": "Format Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Report": {
      "main": [
        [
          {
            "node": "Discord Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  }
}
