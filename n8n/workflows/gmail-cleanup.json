{
  "name": "Gmail Cleanup",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "gmail-cleanup",
        "responseMode": "responseNode"
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        220,
        300
      ],
      "webhookId": "gmail-cleanup"
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "Gmail Cleanup started"
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        440,
        160
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "googleClientId",
              "name": "googleClientId",
              "value": "={{ $env.GOOGLE_CLIENT_ID }}",
              "type": "string"
            },
            {
              "id": "googleClientSecret",
              "name": "googleClientSecret",
              "value": "={{ $env.GOOGLE_CLIENT_SECRET }}",
              "type": "string"
            },
            {
              "id": "googleRefreshToken",
              "name": "googleRefreshToken",
              "value": "={{ $env.GOOGLE_REFRESH_TOKEN }}",
              "type": "string"
            }
          ]
        }
      },
      "id": "set-creds",
      "name": "Set Credentials",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        440,
        380
      ]
    },
    {
      "parameters": {
        "jsCode": "// Gmail Cleanup - Full cleanup logic ported from gmail-trim\n// Defaults to dry-run mode. Use ?mode=live for actual deletion.\n\nconst items = $input.all();\nconst { googleClientId, googleClientSecret, googleRefreshToken } = items[0].json;\n\n// Read webhook query params\nconst webhookData = $('Webhook Trigger').first().json;\nconst queryParams = webhookData.query || {};\nconst mode = (queryParams.mode || 'dry-run').toLowerCase();\nconst daysThreshold = parseInt(queryParams.days || '30', 10);\nconst keepLabel = queryParams.keep_label || 'KEEP';\nconst maxThreads = parseInt(queryParams.max || '500', 10);\n\n// Validate\nif (mode !== 'dry-run' && mode !== 'live') {\n  return [{ json: { report: `ERROR: Invalid mode \"${mode}\". Use \"dry-run\" or \"live\".`, mode } }];\n}\nif (daysThreshold < 1 || daysThreshold > 365) {\n  return [{ json: { report: `ERROR: days must be 1-365, got ${daysThreshold}`, mode } }];\n}\n\n// Get OAuth2 access token\nconst tokenBody = `client_id=${encodeURIComponent(googleClientId)}&client_secret=${encodeURIComponent(googleClientSecret)}&refresh_token=${encodeURIComponent(googleRefreshToken)}&grant_type=refresh_token`;\nconst tokenResp = await this.helpers.httpRequest({\n  method: 'POST',\n  url: 'https://oauth2.googleapis.com/token',\n  body: tokenBody,\n  headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n});\nconst accessToken = tokenResp.access_token;\n\n// Helper: authenticated API requests\nasync function apiRequest(url, method = 'GET') {\n  return await this.helpers.httpRequest({\n    method,\n    url,\n    headers: { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' }\n  });\n}\n\n// Helper: parse KEEP_nD/W/M labels to days\nfunction parseKeepDaysLabel(labelName) {\n  const match = labelName.match(/^KEEP_(\\d{1,3})(D|W|M)$/i);\n  if (!match) return null;\n  const value = parseInt(match[1], 10);\n  const unit = match[2].toLowerCase();\n  const multipliers = { d: 1, w: 7, m: 30 };\n  const days = value * (multipliers[unit] || 1);\n  return (days >= 1 && days <= 3650) ? days : null;\n}\n\n// Helper: extract email addresses from header value\nfunction extractEmails(headerValue) {\n  if (!headerValue) return [];\n  const emailRegex = /[\\w.+-]+@[\\w.-]+\\.\\w+/gi;\n  return (headerValue.match(emailRegex) || []).map(e => e.toLowerCase());\n}\n\nconst errors = [];\nconst stats = {\n  threadsScanned: 0,\n  threadsDeleted: 0,\n  preservedByKeepLabel: 0,\n  preservedByContact: 0,\n  preservedByRetention: 0,\n  preservedByKeepDaysActive: 0,\n  errors: 0\n};\n\n// ============================================================\n// PHASE 1: Discover labels\n// ============================================================\nconst labelsResp = await apiRequest.call(this, 'https://gmail.googleapis.com/gmail/v1/users/me/labels');\nconst allLabels = labelsResp.labels || [];\n\n// Build label maps\nconst labelIdToName = {};\nconst labelNameToId = {};\nfor (const l of allLabels) {\n  labelIdToName[l.id] = l.name;\n  labelNameToId[l.name.toUpperCase()] = l.id;\n}\n\n// Find KEEP label ID\nconst keepLabelId = labelNameToId[keepLabel.toUpperCase()] || null;\n\n// Find all KEEP_nnn labels with retention days\nconst keepDaysLabels = {};\nfor (const l of allLabels) {\n  const days = parseKeepDaysLabel(l.name);\n  if (days !== null) {\n    keepDaysLabels[l.name] = days;\n  }\n}\n\n// ============================================================\n// PHASE 2: Load keeper contacts (People API)\n// ============================================================\nconst keeperEmails = new Set();\n\ntry {\n  const groupsResp = await apiRequest.call(this, 'https://people.googleapis.com/v1/contactGroups?pageSize=1000');\n  const contactGroups = (groupsResp.contactGroups || []).filter(g => g.groupType === 'USER_CONTACT_GROUP');\n  const keeperGroup = contactGroups.find(g => g.name.toLowerCase() === 'keeper');\n\n  if (keeperGroup) {\n    const groupDetail = await apiRequest.call(this, `https://people.googleapis.com/v1/${keeperGroup.resourceName}?maxMembers=1000`);\n    const memberResourceNames = groupDetail.memberResourceNames || [];\n\n    for (let i = 0; i < memberResourceNames.length; i += 50) {\n      const batch = memberResourceNames.slice(i, i + 50);\n      const params = batch.map(r => `resourceNames=${encodeURIComponent(r)}`).join('&');\n      const peopleResp = await apiRequest.call(this, `https://people.googleapis.com/v1/people:batchGet?${params}&personFields=emailAddresses`);\n\n      for (const resp of (peopleResp.responses || [])) {\n        const emails = ((resp.person || {}).emailAddresses || []).map(e => e.value).filter(Boolean);\n        for (const email of emails) {\n          keeperEmails.add(email.toLowerCase());\n        }\n      }\n    }\n  }\n} catch (e) {\n  errors.push(`Contacts API: ${e.message}`);\n}\n\n// ============================================================\n// PHASE 3: Build search query\n// ============================================================\n// Replicate gmail_client.py:build_search_query() logic\nfunction buildSearchQuery() {\n  const commonExclusions = ['-in:trash', '-in:spam'];\n  const commonStr = commonExclusions.join(' ');\n\n  if (Object.keys(keepDaysLabels).length === 0) {\n    // Simple query - no KEEP_nnn labels\n    const parts = [`older_than:${daysThreshold}d`, `-label:${keepLabel}`];\n    parts.push(...commonExclusions);\n    return parts.join(' ');\n  }\n\n  // Compound OR query for KEEP_nnn retention\n  // Part 1: Base query - old emails without any KEEP labels\n  const baseParts = [`older_than:${daysThreshold}d`, `-label:${keepLabel}`];\n  for (const labelName of Object.keys(keepDaysLabels)) {\n    baseParts.push(`-label:${labelName}`);\n  }\n  baseParts.push(commonStr);\n  const baseQuery = `(${baseParts.join(' ')})`;\n\n  // Part 2: Individual KEEP_nnn queries (expired retention)\n  const labelQueries = [];\n  for (const [labelName, retDays] of Object.entries(keepDaysLabels)) {\n    const lqParts = [`older_than:${retDays}d`, `label:${labelName}`, commonStr];\n    labelQueries.push(`(${lqParts.join(' ')})`);\n  }\n\n  return [baseQuery, ...labelQueries].join(' OR ');\n}\n\nconst searchQuery = buildSearchQuery();\n\n// ============================================================\n// PHASE 4: Fetch matching threads with pagination\n// ============================================================\nlet allThreadIds = [];\nlet pageToken = null;\n\ndo {\n  let url = `https://gmail.googleapis.com/gmail/v1/users/me/threads?q=${encodeURIComponent(searchQuery)}&maxResults=100`;\n  if (pageToken) url += `&pageToken=${pageToken}`;\n\n  const threadsResp = await apiRequest.call(this, url);\n  const threads = threadsResp.threads || [];\n  allThreadIds.push(...threads.map(t => t.id));\n  pageToken = threadsResp.nextPageToken || null;\n\n  // Safety limit\n  if (allThreadIds.length >= maxThreads) {\n    allThreadIds = allThreadIds.slice(0, maxThreads);\n    break;\n  }\n} while (pageToken);\n\n// ============================================================\n// PHASE 5: Process each thread - determine preservation\n// ============================================================\nconst toDelete = [];\nconst preserved = [];\n\nfor (const threadId of allThreadIds) {\n  stats.threadsScanned++;\n\n  try {\n    // Get thread metadata\n    const thread = await apiRequest.call(this, `https://gmail.googleapis.com/gmail/v1/users/me/threads/${threadId}?format=metadata&metadataHeaders=From&metadataHeaders=To&metadataHeaders=Cc&metadataHeaders=Subject&metadataHeaders=Date`);\n\n    const messages = thread.messages || [];\n    if (messages.length === 0) continue;\n\n    // Get thread labels (union of all message labels)\n    const threadLabelIds = new Set();\n    for (const msg of messages) {\n      for (const lid of (msg.labelIds || [])) {\n        threadLabelIds.add(lid);\n      }\n    }\n\n    // Get thread label names\n    const threadLabelNames = [...threadLabelIds].map(id => labelIdToName[id] || id);\n\n    // Extract all email addresses from thread\n    const threadAddresses = new Set();\n    let threadSubject = '';\n    let threadDate = null;\n\n    for (const msg of messages) {\n      const headers = msg.payload?.headers || [];\n      for (const h of headers) {\n        const name = h.name.toLowerCase();\n        if (name === 'from' || name === 'to' || name === 'cc') {\n          for (const email of extractEmails(h.value)) {\n            threadAddresses.add(email);\n          }\n        }\n        if (name === 'subject' && !threadSubject) {\n          threadSubject = h.value || '';\n        }\n        if (name === 'date' && !threadDate) {\n          threadDate = new Date(h.value);\n        }\n      }\n    }\n\n    // Determine thread status (preservation check)\n    // Priority: 1. KEEP label  2. Keeper contact  3. KEEP_nnn retention\n\n    // 1. Check KEEP label\n    if (keepLabelId && threadLabelIds.has(keepLabelId)) {\n      stats.preservedByKeepLabel++;\n      preserved.push({ subject: threadSubject.substring(0, 60), reason: 'KEEP label' });\n      continue;\n    }\n\n    // 2. Check keeper contacts\n    let isKeeperContact = false;\n    for (const addr of threadAddresses) {\n      if (keeperEmails.has(addr)) {\n        isKeeperContact = true;\n        stats.preservedByContact++;\n        preserved.push({ subject: threadSubject.substring(0, 60), reason: `keeper: ${addr}` });\n        break;\n      }\n    }\n    if (isKeeperContact) continue;\n\n    // 3. Check KEEP_nnn labels (within retention)\n    let maxRetention = 0;\n    let retentionLabel = null;\n    for (const lName of threadLabelNames) {\n      const retDays = parseKeepDaysLabel(lName);\n      if (retDays !== null && retDays > maxRetention) {\n        maxRetention = retDays;\n        retentionLabel = lName;\n      }\n    }\n\n    if (retentionLabel && threadDate) {\n      const emailAgeDays = (Date.now() - threadDate.getTime()) / (1000 * 60 * 60 * 24);\n      if (emailAgeDays <= maxRetention) {\n        stats.preservedByKeepDaysActive++;\n        preserved.push({ subject: threadSubject.substring(0, 60), reason: `${retentionLabel} (${Math.round(emailAgeDays)}/${maxRetention}d)` });\n        continue;\n      }\n    }\n\n    // Thread is eligible for deletion\n    toDelete.push({ id: threadId, subject: threadSubject.substring(0, 60) });\n\n  } catch (e) {\n    stats.errors++;\n    errors.push(`Thread ${threadId}: ${e.message}`);\n  }\n}\n\n// ============================================================\n// PHASE 6: Execute deletions (live mode only)\n// ============================================================\nif (mode === 'live' && toDelete.length > 0) {\n  for (const thread of toDelete) {\n    try {\n      await apiRequest.call(this, `https://gmail.googleapis.com/gmail/v1/users/me/threads/${thread.id}/trash`, 'POST');\n      stats.threadsDeleted++;\n    } catch (e) {\n      stats.errors++;\n      errors.push(`Trash ${thread.id}: ${e.message}`);\n    }\n  }\n}\n\n// ============================================================\n// PHASE 7: Build report\n// ============================================================\nlet report = `Gmail Cleanup Report (${mode.toUpperCase()})\\n`;\nreport += `Days threshold: ${daysThreshold}, Keep label: ${keepLabel}\\n`;\nreport += `Keeper contacts: ${keeperEmails.size} emails\\n`;\nreport += `KEEP_* labels: ${Object.keys(keepDaysLabels).length} (${Object.entries(keepDaysLabels).map(([k,v]) => `${k}=${v}d`).join(', ') || 'none'})\\n`;\nreport += `Search query: ${searchQuery.substring(0, 200)}${searchQuery.length > 200 ? '...' : ''}\\n\\n`;\n\nreport += `Results:\\n`;\nreport += `  Threads scanned: ${stats.threadsScanned}\\n`;\n\nif (mode === 'live') {\n  report += `  Threads TRASHED: ${stats.threadsDeleted}\\n`;\n} else {\n  report += `  Threads to delete: ${toDelete.length}\\n`;\n}\n\nreport += `  Preserved by KEEP label: ${stats.preservedByKeepLabel}\\n`;\nreport += `  Preserved by keeper contact: ${stats.preservedByContact}\\n`;\nreport += `  Preserved by KEEP_* retention: ${stats.preservedByKeepDaysActive}\\n`;\n\nif (stats.errors > 0) {\n  report += `  Errors: ${stats.errors}\\n`;\n}\n\nif (toDelete.length > 0) {\n  const action = mode === 'live' ? 'Trashed' : 'Would delete';\n  report += `\\n${action} threads (${Math.min(toDelete.length, 20)} of ${toDelete.length}):\\n`;\n  for (const t of toDelete.slice(0, 20)) {\n    report += `  - ${t.subject || '(no subject)'}\\n`;\n  }\n  if (toDelete.length > 20) {\n    report += `  ... and ${toDelete.length - 20} more\\n`;\n  }\n}\n\nif (errors.length > 0) {\n  report += `\\nErrors:\\n`;\n  for (const e of errors.slice(0, 10)) {\n    report += `  - ${e}\\n`;\n  }\n}\n\nreturn [{ json: { report, mode, stats } }];"
      },
      "id": "cleanup-code",
      "name": "Code: Gmail Cleanup",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        660,
        380
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.GOTIFY_URL }}/message",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Gotify-Key",
              "value": "={{ $env.GOTIFY_TOKEN }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ title: 'Gmail Cleanup', message: $json.report, priority: $json.mode === 'live' ? 5 : 3 }) }}"
      },
      "id": "gotify-notify",
      "name": "Notify via Gotify",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        880,
        380
      ]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          },
          {
            "node": "Set Credentials",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Credentials": {
      "main": [
        [
          {
            "node": "Code: Gmail Cleanup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code: Gmail Cleanup": {
      "main": [
        [
          {
            "node": "Notify via Gotify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  }
}
