{
  "name": "Daily Media Digest",
  "description": "Daily digest of media activity across Sonarr, Radarr, and Plex. Summarizes downloads, upcoming episodes, library additions. Sends via Discord.",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 8 * * *"
            }
          ]
        }
      },
      "id": "d0a0a002-0002-4002-a002-000000000001",
      "name": "Daily at 8 AM",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        0,
        304
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "AM7xbizoMlhMEp8x",
          "mode": "list"
        }
      },
      "id": "digest-get-token",
      "name": "Get Plex Token",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.1,
      "position": [
        440,
        304
      ]
    },
    {
      "parameters": {
        "jsCode": "const env = {...$('Globals').first().json, ...$input.first().json};\nconst today = new Date();\nconst startDate = today.toISOString().split('T')[0];\nconst endDate = new Date(today.getTime() + 86400000).toISOString().split('T')[0];\n\nconst sections = [];\n\n// Sonarr - today's calendar\ntry {\n  const sonarrCal = await this.helpers.httpRequest({\n    method: 'GET',\n    url: `${env.SONARR_URL}/api/v3/calendar?start=${startDate}&end=${endDate}`,\n    headers: { 'X-Api-Key': env.SONARR_API_KEY },\n    timeout: 15000\n  });\n  if (sonarrCal.length > 0) {\n    const eps = sonarrCal.map(e => `  â€¢ ${e.series?.title || 'Unknown'} - S${String(e.seasonNumber).padStart(2,'0')}E${String(e.episodeNumber).padStart(2,'0')} - ${e.title || ''}`);\n    sections.push(`ðŸ“º Today's Episodes (${sonarrCal.length}):\\n${eps.join('\\n')}`);\n  } else {\n    sections.push('ðŸ“º No episodes scheduled today');\n  }\n} catch (err) {\n  sections.push(`ðŸ“º Sonarr: Error - ${err.message}`);\n}\n\n// Radarr - queue (downloading)\ntry {\n  const radarrQueue = await this.helpers.httpRequest({\n    method: 'GET',\n    url: `${env.RADARR_URL}/api/v3/queue?pageSize=20`,\n    headers: { 'X-Api-Key': env.RADARR_API_KEY },\n    timeout: 15000\n  });\n  const records = radarrQueue.records || [];\n  if (records.length > 0) {\n    const movies = records.map(r => {\n      const pct = r.sizeleft && r.size ? Math.round((1 - r.sizeleft / r.size) * 100) : 0;\n      return `  â€¢ ${r.title || 'Unknown'} (${pct}%)`;\n    });\n    sections.push(`ðŸŽ¬ Radarr Queue (${records.length}):\\n${movies.join('\\n')}`);\n  } else {\n    sections.push('ðŸŽ¬ Radarr queue is empty');\n  }\n} catch (err) {\n  sections.push(`ðŸŽ¬ Radarr: Error - ${err.message}`);\n}\n\n// SABnzbd - current queue\ntry {\n  const sabQueue = await this.helpers.httpRequest({\n    method: 'GET',\n    url: `${env.SABNZBD_URL}/api?mode=queue&output=json&apikey=${env.SABNZBD_API_KEY}`,\n    timeout: 15000\n  });\n  const queue = sabQueue.queue || {};\n  const slots = queue.slots || [];\n  const speed = queue.speed || '0';\n  if (slots.length > 0) {\n    sections.push(`â¬‡ï¸ SABnzbd: ${slots.length} item(s) downloading at ${speed}/s`);\n  } else {\n    sections.push('â¬‡ï¸ SABnzbd: Idle');\n  }\n} catch (err) {\n  sections.push(`â¬‡ï¸ SABnzbd: Error - ${err.message}`);\n}\n\n// Plex - library stats\ntry {\n  const plexLibs = await this.helpers.httpRequest({\n    method: 'GET',\n    url: `${env.PLEX_URL}/library/sections`,\n    headers: { 'X-Plex-Token': env.PLEX_TOKEN, 'Accept': 'application/json' },\n    timeout: 15000\n  });\n  const dirs = plexLibs?.MediaContainer?.Directory || [];\n  if (dirs.length > 0) {\n    const libs = dirs.map(d => `  â€¢ ${d.title}: ${d.type}`);\n    sections.push(`ðŸŽžï¸ Plex Libraries:\\n${libs.join('\\n')}`);\n  }\n} catch (err) {\n  sections.push(`ðŸŽžï¸ Plex: Error - ${err.message}`);\n}\n\n// Overseerr - pending requests\ntry {\n  const requests = await this.helpers.httpRequest({\n    method: 'GET',\n    url: `${env.OVERSEERR_URL}/api/v1/request?take=10&filter=pending`,\n    headers: { 'X-Api-Key': env.OVERSEERR_API_KEY },\n    timeout: 15000\n  });\n  const pending = requests.results || [];\n  if (pending.length > 0) {\n    sections.push(`ðŸ“‹ Overseerr: ${pending.length} pending request(s)`);\n  } else {\n    sections.push('ðŸ“‹ Overseerr: No pending requests');\n  }\n} catch (err) {\n  sections.push(`ðŸ“‹ Overseerr: Error - ${err.message}`);\n}\n\nconst message = sections.join('\\n\\n');\n\nreturn [{\n  json: {\n    title: `ðŸ“Š Daily Media Digest - ${startDate}`,\n    message: message,\n    priority: 3\n  }\n}];"
      },
      "id": "d0a0a002-0002-4002-a002-000000000002",
      "name": "Gather Media Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        660,
        304
      ]
    },
    {
      "parameters": {
        "authentication": "webhook",
        "resource": "webhook",
        "operation": "sendLegacy",
        "content": "",
        "embeds": {
          "values": [
            {
              "inputMethod": "json",
              "json": "={{ JSON.stringify({ title: $json.title, description: $json.message, color: ($json.priority || 3) >= 7 ? 15158332 : ($json.priority || 3) >= 5 ? 16776960 : 3066993, timestamp: new Date().toISOString() }) }}"
            }
          ]
        },
        "options": {}
      },
      "id": "d0a0a002-0002-4002-a002-000000000003",
      "name": "Discord Digest",
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [
        880,
        304
      ],
      "credentials": {
        "discordWebhookApi": {
          "id": "410BCHcgoAHtBHHk",
          "name": "Discord Webhook"
        }
      }
    },
    {
      "parameters": {
        "putAllInOneKey": false
      },
      "id": "globals-node",
      "name": "Globals",
      "type": "n8n-nodes-globals.globalConstants",
      "typeVersion": 1,
      "position": [
        220,
        304
      ],
      "credentials": {
        "globalConstantsApi": {
          "id": "kt9rQnvdyaBeZlR2",
          "name": "Homelab Constants"
        }
      }
    }
  ],
  "connections": {
    "Daily at 8 AM": {
      "main": [
        [
          {
            "node": "Globals",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Plex Token": {
      "main": [
        [
          {
            "node": "Gather Media Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gather Media Data": {
      "main": [
        [
          {
            "node": "Discord Digest",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Globals": {
      "main": [
        [
          {
            "node": "Get Plex Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  }
}
