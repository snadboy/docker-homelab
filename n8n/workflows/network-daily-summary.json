{
  "name": "Daily Network Summary",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 8 * * *"
            }
          ]
        }
      },
      "id": "nds-trigger",
      "name": "Daily 8:00 AM",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        0,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const globals = $('Globals').first().json;\nconst UNIFI_URL = globals.UNIFI_URL;\nconst UNIFI_USERNAME = globals.UNIFI_USERNAME;\nconst UNIFI_PASSWORD = globals.UNIFI_PASSWORD;\nconst httpRequest = this.helpers.httpRequest.bind(this.helpers);\n\nfunction formatUptime(seconds) {\n  const d = Math.floor(seconds / 86400);\n  const h = Math.floor((seconds % 86400) / 3600);\n  if (d > 0) return `${d}d ${h}h`;\n  return `${h}h`;\n}\n\nconst parts = [];\n\ntry {\n  // 1. Authenticate to UniFi\n  const loginResp = await httpRequest({\n    method: 'POST',\n    url: `${UNIFI_URL}/api/auth/login`,\n    body: { username: UNIFI_USERNAME, password: UNIFI_PASSWORD },\n    returnFullResponse: true,\n    skipSslCertificateValidation: true,\n    json: true\n  });\n\n  const rawCookies = loginResp.headers['set-cookie'];\n  let cookieStr = '';\n  if (Array.isArray(rawCookies)) {\n    cookieStr = rawCookies.map(c => c.split(';')[0]).join('; ');\n  } else if (typeof rawCookies === 'string') {\n    cookieStr = rawCookies.split(';')[0];\n  }\n\n  async function unifiGet(path) {\n    const raw = await httpRequest({\n      url: `${UNIFI_URL}${path}`,\n      headers: { Cookie: cookieStr },\n      skipSslCertificateValidation: true\n    });\n    return typeof raw === 'string' ? JSON.parse(raw) : raw;\n  }\n\n  // 2. WAN Health & Gateway\n  const healthResp = await unifiGet('/proxy/network/api/s/default/stat/health');\n  const subsystems = healthResp.data || [];\n  const wan = subsystems.find(s => s.subsystem === 'wan');\n\n  if (wan) {\n    const gwStats = wan['gw_system-stats'] || {};\n    const gwUptime = formatUptime(parseInt(gwStats.uptime || 0));\n    const gwCpu = parseFloat(gwStats.cpu || 0).toFixed(0);\n    const gwMem = parseFloat(gwStats.mem || 0).toFixed(0);\n    const ispName = wan.isp_name || 'Unknown';\n\n    const uptimeStats = wan.uptime_stats || {};\n    const wan1Stats = uptimeStats.WAN || {};\n    const wan1Latency = wan1Stats.latency_average || 0;\n    parts.push(`**\\u{1f310} WAN (${ispName})**\\nIP: ${wan.wan_ip || 'N/A'} | Latency: ${wan1Latency}ms | Status: ${wan.status}`);\n\n    const wan2Stats = uptimeStats.WAN2;\n    if (wan2Stats) {\n      const wan2Latency = wan2Stats.latency_average || 0;\n      parts.push(`**\\u{1f310} WAN2 (T-Mobile)**\\nLatency: ${wan2Latency}ms | Status: ok`);\n    }\n\n    parts.push(`**\\u{1f5a5}\\ufe0f ${wan.gw_name || 'Gateway'}**\\nCPU: ${gwCpu}% | Mem: ${gwMem}% | Up: ${gwUptime} | FW: ${wan.gw_version || 'N/A'}`);\n  }\n\n  // 3. Speedtest results\n  const speedResp = await unifiGet('/proxy/network/v2/api/site/default/speedtest');\n  const speedResults = speedResp.data || [];\n  const latestByWan = {};\n  for (const r of speedResults) {\n    const ng = r.wan_networkgroup;\n    if (!ng || r.download_mbps === 0) continue;\n    if (!latestByWan[ng] || r.time > latestByWan[ng].time) latestByWan[ng] = r;\n  }\n  const speedParts = [];\n  if (latestByWan.WAN) {\n    const s = latestByWan.WAN;\n    speedParts.push(`WAN: ${s.download_mbps}\\u2193/${s.upload_mbps}\\u2191 Mbps (${s.latency_ms}ms)`);\n  }\n  if (latestByWan.WAN2) {\n    const s = latestByWan.WAN2;\n    speedParts.push(`WAN2: ${s.download_mbps}\\u2193/${s.upload_mbps}\\u2191 Mbps (${s.latency_ms}ms)`);\n  }\n  if (speedParts.length > 0) {\n    parts.push(`**\\u{1f4c8} Last Speedtest**\\n${speedParts.join(' | ')}`);\n  }\n\n  // 4. Devices\n  const devResp = await unifiGet('/proxy/network/api/s/default/stat/device');\n  const devices = devResp.data || [];\n  const aps = devices.filter(d => d.type === 'uap');\n  const switches = devices.filter(d => d.type === 'usw' || d.type === 'udb');\n  const apsOnline = aps.filter(d => d.state === 1).length;\n  const swOnline = switches.filter(d => d.state === 1).length;\n\n  // 5. WiFi clients\n  const staResp = await unifiGet('/proxy/network/api/s/default/stat/sta');\n  const clients = staResp.data || [];\n  const sats = clients.filter(c => c.satisfaction !== undefined).map(c => c.satisfaction);\n  const avgSat = sats.length > 0 ? Math.round(sats.reduce((a, b) => a + b, 0) / sats.length) : 0;\n  const poorSat = sats.filter(s => s < 50).length;\n  const weakSignal = clients.filter(c => c.signal !== undefined && c.signal < -80).length;\n\n  parts.push(`**\\u{1f4e1} Devices & Clients**\\n${apsOnline}/${aps.length} APs | ${swOnline}/${switches.length} switches | ${clients.length} WiFi clients | Avg satisfaction: ${avgSat}%${poorSat > 0 ? ` | ${poorSat} poor` : ''}${weakSignal > 0 ? ` | ${weakSignal} weak signal` : ''}`);\n\n} catch (err) {\n  parts.push(`**\\u274c Error**\\nUniFi API: ${err.message}`);\n}\n\nreturn [{ json: { unifiDesc: parts.join('\\n\\n') } }];"
      },
      "id": "nds-unifi",
      "name": "Gather UniFi Stats",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        440,
        300
      ]
    },
    {
      "parameters": {
        "resource": "command",
        "operation": "execute",
        "command": "docker ps -a --filter name=cloudflare --format json | jq -r '[.Names, .State, .Status] | join(\"|\")'",
        "authentication": "privateKey",
        "options": {}
      },
      "id": "nds-ssh-cadre",
      "name": "SSH cadre tunnels",
      "type": "n8n-nodes-base.ssh",
      "typeVersion": 1,
      "position": [
        440,
        100
      ],
      "onError": "continueRegularOutput",
      "credentials": {
        "sshPrivateKey": {
          "id": "H1zhHsKxDwEDOSRk",
          "name": "cadre SSH"
        }
      }
    },
    {
      "parameters": {
        "resource": "command",
        "operation": "execute",
        "command": "docker ps -a --filter name=cloudflare --format json | jq -r '[.Names, .State, .Status] | join(\"|\")'",
        "authentication": "privateKey",
        "options": {}
      },
      "id": "nds-ssh-utilities",
      "name": "SSH utilities tunnels",
      "type": "n8n-nodes-base.ssh",
      "typeVersion": 1,
      "position": [
        440,
        500
      ],
      "onError": "continueRegularOutput",
      "credentials": {
        "sshPrivateKey": {
          "id": "n8816WsRbTEbFnjD",
          "name": "utilities SSH"
        }
      }
    },
    {
      "parameters": {
        "mode": "append",
        "numberInputs": 3,
        "options": {}
      },
      "id": "nds-merge",
      "name": "Merge Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        660,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\n// Collect UniFi description\nlet desc = '';\nfor (const item of items) {\n  if (item.json.unifiDesc) {\n    desc = item.json.unifiDesc;\n  }\n}\n\n// Process SSH tunnel results\nconst expectedTunnels = [\n  'cloudflare-plex',\n  'cloudflare-overseerr',\n  'cloudflared-gotify',\n  'cloudflare-dockhand'\n];\nconst foundTunnels = {};\n\nfor (const item of items) {\n  const stdout = item.json.stdout;\n  if (stdout === undefined) continue;\n  const lines = stdout.trim().split('\\n').filter(l => l.length > 0);\n  for (const line of lines) {\n    const parts = line.split('|');\n    const name = (parts[0] || '').trim();\n    const state = (parts[1] || '').trim();\n    const status = (parts[2] || '').trim();\n    if (name) foundTunnels[name] = { state, status };\n  }\n}\n\nconst tunnelParts = [];\nlet tunnelsRunning = 0;\nfor (const tunnel of expectedTunnels) {\n  const info = foundTunnels[tunnel];\n  const shortName = tunnel.replace('cloudflare-', '').replace('cloudflared-', '');\n  if (info && info.state === 'running') {\n    tunnelsRunning++;\n    tunnelParts.push(shortName);\n  } else {\n    tunnelParts.push(`**${shortName}** (DOWN)`);\n  }\n}\n\ndesc += `\\n\\n**\\u2601\\ufe0f Cloudflare Tunnels**\\n${tunnelsRunning}/${expectedTunnels.length} running (${tunnelParts.join(', ')})`;\n\nconst today = new Date().toLocaleDateString('en-US', {\n  year: 'numeric', month: 'short', day: 'numeric', timeZone: 'America/New_York'\n});\n\nreturn [{\n  json: {\n    title: `\\u{1f4e1} Daily Network Report \\u2014 ${today}`,\n    color: 3447003,\n    description: desc,\n    footer: 'Gateway: Cloud Gateway Max | Primary: Metronet | Backup: T-Mobile',\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "nds-format",
      "name": "Format Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        880,
        300
      ]
    },
    {
      "parameters": {
        "authentication": "webhook",
        "resource": "webhook",
        "operation": "sendLegacy",
        "content": "",
        "embeds": {
          "values": [
            {
              "inputMethod": "json",
              "json": "={{ JSON.stringify({ title: $json.title, description: $json.description, color: $json.color, footer: { text: $json.footer }, timestamp: $json.timestamp }) }}"
            }
          ]
        },
        "options": {}
      },
      "id": "nds-discord",
      "name": "Discord Summary",
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [
        1100,
        300
      ],
      "credentials": {
        "discordWebhookApi": {
          "id": "410BCHcgoAHtBHHk",
          "name": "Discord Webhook"
        }
      }
    },
    {
      "parameters": {
        "putAllInOneKey": false
      },
      "id": "globals-node",
      "name": "Globals",
      "type": "n8n-nodes-globals.globalConstants",
      "typeVersion": 1,
      "position": [
        220,
        300
      ],
      "credentials": {
        "globalConstantsApi": {
          "id": "kt9rQnvdyaBeZlR2",
          "name": "Homelab Constants"
        }
      }
    }
  ],
  "connections": {
    "Daily 8:00 AM": {
      "main": [
        [
          {
            "node": "Globals",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gather UniFi Stats": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SSH cadre tunnels": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "SSH utilities tunnels": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Merge Results": {
      "main": [
        [
          {
            "node": "Format Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Summary": {
      "main": [
        [
          {
            "node": "Discord Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Globals": {
      "main": [
        [
          {
            "node": "Gather UniFi Stats",
            "type": "main",
            "index": 0
          },
          {
            "node": "SSH cadre tunnels",
            "type": "main",
            "index": 0
          },
          {
            "node": "SSH utilities tunnels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  }
}
